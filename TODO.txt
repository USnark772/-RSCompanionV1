To deal with at some point:
-   Change output path to fixed and user can change it if desired but doesn't need to.
-   Give program a folder in user space instead of program files space and place config file in there.
-   Fix time on charts and output files so that it matches the time shown in users computers.
-   Chart Y axes need to be set to default values VOG 0-12 seconds, DRT RT 0-2500ms, Clicks 0-3
-   GPS integration
-   Possibly use numpy for internal data storage.
-   Design good way to calculate mean of each data type
    -   Let user set the bounds of the mean
-   When scrolling, the graphs move in their canvasas
-   Some unexplained issues with ui sizing (Has to do with screen scaling)
-   Add button that leads to last used directory for saving.
-   Add cpu resource monitor to code with possible color coding based on percentage. < 70% is green, 70% - 90% yellow, > 90% red.

In progress:
-   Refactor so that all device logic (device manager messaging etc.) is in the device specific files
    Would we need to pass a reference to the device controller's respective function in?
    Video:
    -   Create exp starts recording video (Done).
    -   Device overlay is recorded with the video
    -   Device output will add a frame # for when that device output came in
    -   Figure out all the configuration ideas for cameras and put them in the tabs.
    -   Add camera deactivation options. (Done)
    -   Also see if can disconnect from specific cameras. (Done)
        -   Should we disable removing cameras during an experiment?
        -   If we enable a camera during an experiment should it just wait until next experiment or should it join?

Dealt with:
-   Think about how to manage licenses ( Is this software worth protecting or is it useless without our specific devices? )
    Using GPL 3.0 or later at this time.
-   Check for updates is not working. (Solution: Make sure repo is public)

Updater:
-   Automatically download latest version at users request
-   Automatically check for updates at startup if user selects that option

to get stack trace
-   from traceback import print_stack
    print_stack() where you want a stacktrace
to get exceptions
-   from traceback import print_exc
    print_exc(filename)
